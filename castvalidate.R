# The Chase Algorithm (in R) Rich Cotler March 2018 A simple application to
# execute a basic Chase Algorithm given a premise of join and functional
# dependencies.  Input validation functions

sumIntoTable <- function(inputtable, classvalue, summarytype) {
  # Creates summary on JD input attribute value from jd input data table summary
  # levels initially 'x' or 'y' counts by column name or row number.  Args:
  # inputtable: dependency tableau data table classvalue: counts of resolved 'x' or
  # unresolved 'y' cells summarytype: 'row' or 'column' Returns: tmptable: data
  # frame with column or row names and associated classvalue counts
  if (summarytype == "row") {
    grpcolumn <- c("rownumber")  # summarytype = row
  } else {
    grpcolumn <- c("columnname")  # summarytype = column
  }
  classfilter <- str_c("classvalue == '", classvalue, "'")
  
  tmptable <- inputtable %>% filter_(.dots = classfilter) %>% count_(vars = grpcolumn)
  setnames(tmptable, c(grpcolumn, str_c(classvalue, "count")))
  return(tmptable)
}

validateJDInput <- function(sourcetable, colcount, rowcount) {
  # Check values selected in join dependency entry, returns a data table containing
  # any error message generated by validation.  Successful validation is
  # communicated to the caller by returning an empty error message data table.
  # Args: sourcetable: initial dependency tableau data table colcount: number of
  # columns in sourcetable rowcount: number of rows in sourcetable Returns:
  # jdErrorMsgTable: data table with a row for each error condition raised, empty
  # if no errors encountered
  jdErrorMsgTable <- setNames(data.table(matrix("", nrow = 0, ncol = 1)), c("ErrorMessage"))
  
  jdtablelist <- as.list(sourcetable[, 1:eval(colcount)])
  fmtlist <- lapply(jdtablelist, function(x) {
    x <- str_sub(x, 1, 1)
  })
  fmtvector <- unlist(fmtlist)
  collist <- lapply(names(fmtvector), function(x) {
    x <- str_sub(x, 1, 1)
  })
  rowlist <- lapply(names(fmtvector), function(x) {
    x <- str_sub(x, 2, length(x) - 2)
  })
  valuelist <- flatten(fmtlist)
  
  ## check for duplicate JD rows
  duplicatechecklv <- duplicated(setDT(fmtlist))
  if (any(duplicatechecklv) == TRUE) {
    lvidx <- c(1:rowcount)
    jdErrorMsgTable <- add_row(jdErrorMsgTable, ErrorMessage = str_c("Duplicate Join Dependency, row ", 
      lvidx[duplicatechecklv], "."))
  }
  
  ## create column, row number, value table for validation queries
  jdinputtable <- data.table(unlist(collist), unlist(rowlist), unlist(valuelist))
  setnames(jdinputtable, c("columnname", "rownumber", "classvalue"))
  
  ## create value counts (x's and y's) by column
  xcoltable <- sumIntoTable(jdinputtable, "x", "column")
  ycoltable <- sumIntoTable(jdinputtable, "y", "column")
  coltable <- xcoltable %>% full_join(ycoltable) %>% arrange(columnname)
  
  ## check that every column is referenced in at least one JD
  for (ridx in 1:nrow(coltable)) {
    if (is.na(coltable$xcount[ridx])) {
      jdErrorMsgTable <- add_row(jdErrorMsgTable, ErrorMessage = str_c("JD for column ", 
        coltable$columnname[ridx], " not defined."))
    }
  }
  
  ## create value counts (x's and y's) by row number
  xrowtable <- sumIntoTable(jdinputtable, "x", "row")
  yrowtable <- sumIntoTable(jdinputtable, "y", "row")
  rowtable <- xrowtable %>% full_join(yrowtable) %>% arrange(rownumber)
  
  ## check for empty JD rows, JD rows with only one column selected (which IS NOT a
  ## JOIN :-), and any column where ALL columns are selected (which is useless in a
  ## Chase Algorithm, AKA Chase is complete)
  for (ridx in 1:nrow(rowtable)) {
    if (is.na(rowtable$xcount[ridx])) {
      jdErrorMsgTable <- add_row(jdErrorMsgTable, ErrorMessage = str_c("JD row ", 
        rowtable$rownumber[ridx], " is empty."))
    } else if (rowtable$xcount[ridx] == 1) {
      jdErrorMsgTable <- add_row(jdErrorMsgTable, ErrorMessage = str_c("JD row ", 
        rowtable$rownumber[ridx], " has only 1 entry."))
    } else if (rowtable$xcount[ridx] == colcount) {
      jdErrorMsgTable <- add_row(jdErrorMsgTable, ErrorMessage = str_c("JD row ", 
        rowtable$rownumber[ridx], " has all columns selected."))
    }
  }
  ## return any errors encountered by JD validation
  setnames(jdErrorMsgTable, c("Join Dependency Validation Errors"))
  jdErrorMsgTable <- datatable(jdErrorMsgTable, rownames = FALSE, selection = "none", 
    editable = FALSE, options = list(paging = FALSE, ordering = FALSE, searching = FALSE, 
      info = FALSE, selection = "none"))
  return(jdErrorMsgTable)
}

validateFDInput <- function(determinantnew, dependentnew) {
  # Check after adding each functional dependency to the FD list for duplicate,
  # inverse, or trivial FD condition, returns a data table containing any error
  # message generated by validation.  Successful validation is communicated to the
  # caller by returning an empty error message data table.  Args: determinantnew:
  # functional dependency determinant list dependentnew: functional dependency
  # dependent list Returns: fdErrorMsgTable: data table with a row for each error
  # condition raised, empty if no errors encountered
  
  fdErrorMsgTable <- setNames(data.table(matrix("", nrow = 0, ncol = 1)), c("ErrorMessage"))
  fdinputtable <- data.table(unlist(determinantnew), unlist(dependentnew))
  setnames(fdinputtable, c("determinant", "dependent"))
  
  # check to see if there is a duplicate FD consdition if not, create FD inversion
  # entry table, which we invert, combine with the regular FDs, and check to see if
  # that causes duplicate rows (original and inversion) to be flagged.
  duplicatechecklv <- duplicated(fdinputtable)
  if (any(duplicatechecklv) == TRUE) {
    fdErrorMsgTable <- add_row(fdErrorMsgTable, ErrorMessage = str_c("Duplicate Functional Dependency entered."))
  } else {
    invertfds <- fdinputtable %>% select(dependent, determinant)
    setnames(invertfds, c("determinant", "dependent"))
    inversionchecktable <- bind_rows(fdinputtable, invertfds)
    duplicatechecklv <- duplicated(inversionchecktable)
    if (any(duplicatechecklv) == TRUE) {
      lvidx <- c(1:nrow(inversionchecktable))
      invnvector <- unlist(as.list(inversionchecktable %>% .[duplicatechecklv]))
      fdErrorMsgTable <- add_row(fdErrorMsgTable, ErrorMessage = str_c("Inversion entered: { ", 
        invnvector["determinant1"], " -> ", invnvector["dependent1"], ", ", 
        invnvector["determinant2"], " -> ", invnvector["dependent2"], " }"))
    }
  }
  
  # check if there are any trivial FDs requested, if so raise an error
  trivialfds <- fdinputtable %>% filter(str_detect(determinant, dependent))
  if (nrow(trivialfds) > 0) {
    trivialvector <- unlist(as.list(trivialfds))
    fdErrorMsgTable <- add_row(fdErrorMsgTable, ErrorMessage = str_c("Trivial FD entered: { ", 
      trivialvector["determinant"], " -> ", trivialvector["dependent"], " }"))
  }
  
  setnames(fdErrorMsgTable, c("Functional Dependency Validation Errors"))
  fdErrorMsgTable <- datatable(fdErrorMsgTable, rownames = FALSE, selection = "none", 
    editable = FALSE, options = list(paging = FALSE, ordering = FALSE, searching = FALSE, 
      info = FALSE, selection = "none"))
  return(fdErrorMsgTable)
}

